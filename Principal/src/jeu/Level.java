package jeu;
public class Level {
	String editedfile,path;
	savedpath sp;
	//x = 6; y = 6; z = 6
	
    /* Les niveaux sont cr√©es comme suit : */
    /*
    1. Les "0x0" correspondent √† des bloques vides, les "0x1" √† des blocs normaux (marrons), les "0x2" aux blocs 
    finaux (verts), et les "0x3" aux blocs de d√©but (bleu)

    2. Chaque "bloc" est un √©tage, donc le level 1 qui ne contient qu'un seul "bloc" ne contient qu'un seul √©tage, 
    et le niveau 3 contient 6 √©tages. Ceci correspond √† l'axe Z.
    
    3. Chaque ligne correspond √† une ligne de l'axe X. Donc d√©placement avec les touches gauche et droite du clavier.
    
    4. Chaque colonne correspond √† une ligne de l'axe Y. Donc d√©placement avec les touches haut et bas du clavier.
    */
  
	Byte[] level1 = { 
			
			0x3,0x1,0x1,0x1,0x1,0x1,
			0x1,0x1,0x1,0x1,0x1,0x1,
			0x1,0x1,0x1,0x1,0x1,0x1,
			0x0,0x0,0x0,0x0,0x0,0x0,
			0x1,0x1,0x1,0x1,0x1,0x1,
			0x1,0x1,0x1,0x1,0x1,0x2,
			
			0x3,0x1,0x1,0x0,0x0,0x0,
			0x1,0x1,0x1,0x0,0x1,0x0,
			0x1,0x1,0x1,0x0,0x0,0x0,
			0x0,0x0,0x0,0x0,0x0,0x0,
			0x0,0x0,0x0,0x0,0x0,0x0,
			0x0,0x0,0x0,0x0,0x0,0x0,
			
			0x0,0x0,0x1,0x0,0x0,0x0,
			0x0,0x0,0x1,0x0,0x1,0x0,
			0x1,0x1,0x1,0x0,0x0,0x0,
			0x0,0x0,0x0,0x0,0x0,0x0,
			0x0,0x0,0x0,0x0,0x0,0x0,
			0x0,0x0,0x0,0x0,0x0,0x0
			
	};
	
	Byte[] level2 = { 
			
			0x3,0x1,0x1,0x1,0x1,0x1,
			0x1,0x1,0x1,0x1,0x1,0x1,
			0x1,0x1,0x1,0x1,0x1,0x1,
			0x0,0x0,0x0,0x0,0x0,0x0,
			0x0,0x0,0x0,0x0,0x0,0x0,
			0x1,0x1,0x1,0x1,0x1,0x2,
			
			0x0,0x0,0x1,0x0,0x0,0x0,
			0x0,0x0,0x1,0x0,0x1,0x0,
			0x1,0x1,0x1,0x0,0x0,0x0,
			0x0,0x0,0x0,0x0,0x0,0x0,
			0x0,0x0,0x0,0x0,0x0,0x0,
			0x0,0x0,0x0,0x0,0x0,0x0
			
	};
	
	Byte[] level3 = { 
			//1er √É¬©tage
			0x3,0x1,0x1,0x1,0x1,0x1,
			0x1,0x1,0x1,0x1,0x1,0x1,
			0x1,0x1,0x1,0x1,0x1,0x1,
			0x1,0x1,0x1,0x1,0x1,0x1,
			0x1,0x1,0x1,0x1,0x1,0x1,
			0x1,0x1,0x1,0x1,0x1,0x2,
			//2√É¬©me √É¬©tage
			0x1,0x1,0x1,0x1,0x1,0x0,
			0x1,0x1,0x1,0x1,0x1,0x0,
			0x1,0x1,0x1,0x1,0x1,0x0,
			0x1,0x1,0x1,0x1,0x1,0x0,
			0x1,0x1,0x1,0x1,0x1,0x0,
			0x0,0x0,0x0,0x0,0x0,0x0,
			//etc
			0x1,0x1,0x1,0x1,0x0,0x0,
			0x1,0x1,0x1,0x1,0x0,0x0,
			0x1,0x1,0x1,0x1,0x0,0x0,
			0x1,0x1,0x1,0x1,0x0,0x0,
			0x0,0x0,0x0,0x0,0x0,0x0,
			0x0,0x0,0x0,0x0,0x0,0x0,
			
			0x1,0x1,0x1,0x0,0x0,0x0,
			0x1,0x1,0x1,0x0,0x0,0x0,
			0x1,0x1,0x1,0x0,0x0,0x0,
			0x0,0x0,0x0,0x0,0x0,0x0,
			0x0,0x0,0x0,0x0,0x0,0x0,
			0x0,0x0,0x0,0x0,0x0,0x0,
	
			0x1,0x1,0x0,0x0,0x0,0x0,
			0x1,0x1,0x0,0x0,0x0,0x0,
			0x0,0x0,0x0,0x0,0x0,0x0,
			0x0,0x0,0x0,0x0,0x0,0x0,
			0x0,0x0,0x0,0x0,0x0,0x0,
			0x0,0x0,0x0,0x0,0x0,0x0,
			
			0x3,0x0,0x0,0x0,0x0,0x0,
			0x0,0x0,0x0,0x0,0x0,0x0,
			0x0,0x0,0x0,0x0,0x0,0x0,
			0x0,0x0,0x0,0x0,0x0,0x0,
			0x0,0x0,0x0,0x0,0x0,0x0,
			0x0,0x0,0x0,0x0,0x0,0x0,
			
			0x0,0x0,0x0,0x0,0x0,0x0,
			0x0,0x0,0x0,0x0,0x0,0x0,
			0x0,0x0,0x0,0x0,0x0,0x0,
			0x0,0x0,0x0,0x0,0x0,0x0,
			0x0,0x0,0x0,0x0,0x0,0x0,
			0x0,0x0,0x0,0x0,0x0,0x0
	};
	
	Byte[] level4 = { 
			
			0x3,0x1,0x1,0x1,0x1,0x1,
			0x1,0x1,0x1,0x1,0x1,0x1,
			0x1,0x1,0x1,0x1,0x1,0x1,
			0x1,0x1,0x1,0x1,0x1,0x1,
			0x1,0x1,0x1,0x1,0x1,0x1,
			0x1,0x1,0x1,0x1,0x1,0x2,
			
			0x0,0x0,0x0,0x0,0x0,0x0,
			0x0,0x0,0x1,0x0,0x1,0x0,
			0x0,0x0,0x1,0x0,0x1,0x0,
			0x0,0x0,0x0,0x0,0x0,0x0,
			0x0,0x0,0x0,0x0,0x1,0x0,
			0x0,0x0,0x0,0x0,0x0,0x0
			
	};
	
	
	// Il y a 2 Ètages pour l'Èventuel ajout d'un Ètage
	Byte[] level5 = { 
			
			0x3,0x1,0x1,0x1,0x1,0x1,
			0x0,0x0,0x0,0x0,0x0,0x1,
			0x1,0x1,0x1,0x1,0x1,0x1,
			0x1,0x0,0x0,0x0,0x0,0x0,
			0x1,0x0,0x1,0x1,0x1,0x1,
			0x1,0x1,0x1,0x0,0x0,0x2,	
			
			0x0,0x0,0x0,0x0,0x0,0x0,
			0x0,0x0,0x0,0x0,0x0,0x0,
			0x0,0x0,0x0,0x0,0x0,0x0,
			0x0,0x0,0x0,0x0,0x0,0x0,
			0x0,0x0,0x0,0x0,0x0,0x0,
			0x0,0x0,0x0,0x0,0x0,0x0
			
	};
	
	
	boolean solvable;
	Byte difficulty;
	Level(){
		
	}
	
	public int getX(int niv){
		switch (niv){
		case 1:
			return 6;
		case 2:
			return 6;
		case 3:
			return 6;
		case 4 :
			return 6;
		case 5 : 
			return 6;
		default : 
			return 6;
		}
	}
	
	public int getY(int niv){
		switch (niv){
		case 1:
			return 6;
		case 2:
			return 6;
		case 3:
			return 6;
		case 4 :
			return 6;
		case 5 : 
			return 6;
		default : 
			return 6;
		}
	}

	public int getZ(int niv){
		switch (niv){
		case 1:
			return 3;
		case 2:
			return 2;
		case 3:
			return 7;
		case 4 :
			return 2;
		case 5 : 
			return 2;
		default : 
			return 1;
		}
	}
	
	
	// Fonction qui retourne le "byte" correspondant au bloc voulu
		public Byte niveau(int niv,int numbloc){
			switch (niv){
			case 1:
				return level1[numbloc];
			case 2:
				return level2[numbloc];
			case 3 :
				return level3[numbloc];
			case 4 :
				return level4[numbloc];
			case 5 :
				return level5[numbloc];
			default :
				return level1[numbloc];
			}
		}
	
	// Fonction qui retourne si oui ou non la case est une case d'arriv√©e (de sortie)	
		public boolean arrivee(int niv, int numbloc){
			switch (niv){
			case 1:
				if (numbloc == 35) 
					return true;
				else
					return false;
			case 2:
				if (numbloc == 35) 
					return true;
				else
					return false;
			case 3:
				if (numbloc == 35) 
					return true;
				else
					return false;
			case 4:
				if (numbloc == 35) 
					return true;
				else
					return false;
			case 5:
				if (numbloc == 35) 
					return true;
				else
					return false;
			default: 
					return false;
			}
		}
}
