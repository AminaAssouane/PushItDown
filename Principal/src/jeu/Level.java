package jeu;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;

public class Level {
	String editedfile,path;
	savedpath sp;
	//x = 6; y = 6; z = 6
	
    /* Les niveaux sont crÃƒÂ©es comme suit : */
    /*
    1. Les "0x0" correspondent ÃƒÂ  des bloques vides, les "0x1" ÃƒÂ  des blocs normaux (marrons), les "0x2" aux blocs 
    finaux (verts), et les "0x3" aux blocs de dÃƒÂ©but (bleu)

    2. Chaque "bloc" est un ÃƒÂ©tage, donc le level 1 qui ne contient qu'un seul "bloc" ne contient qu'un seul ÃƒÂ©tage, 
    et le niveau 3 contient 6 ÃƒÂ©tages. Ceci correspond ÃƒÂ  l'axe Z.
    
    3. Chaque ligne correspond ÃƒÂ  une ligne de l'axe X. Donc dÃƒÂ©placement avec les touches gauche et droite du clavier.
    
    4. Chaque colonne correspond ÃƒÂ  une ligne de l'axe Y. Donc dÃƒÂ©placement avec les touches haut et bas du clavier.
    */
  
	byte[] level1 = { 
			
			0x3,0x1,0x1,0x1,0x1,0x1,
			0x1,0x1,0x1,0x1,0x1,0x1,
			0x1,0x1,0x1,0x1,0x1,0x1,
			0x0,0x0,0x0,0x0,0x0,0x0,
			0x1,0x1,0x1,0x1,0x1,0x1,
			0x1,0x1,0x1,0x1,0x1,0x2,
			
			0x3,0x1,0x1,0x0,0x0,0x0,
			0x1,0x1,0x1,0x0,0x1,0x0,
			0x1,0x1,0x1,0x0,0x0,0x0,
			0x0,0x0,0x0,0x0,0x0,0x0,
			0x0,0x0,0x0,0x0,0x0,0x0,
			0x0,0x0,0x0,0x0,0x0,0x0,
			
			0x0,0x0,0x1,0x0,0x0,0x0,
			0x0,0x0,0x1,0x0,0x1,0x0,
			0x1,0x1,0x1,0x0,0x0,0x0,
			0x0,0x0,0x0,0x0,0x0,0x0,
			0x0,0x0,0x0,0x0,0x0,0x0,
			0x0,0x0,0x0,0x0,0x0,0x0
			
	};
	
	Byte[] level2 = { 
			
			0x3,0x1,0x1,0x1,0x1,0x1,
			0x1,0x1,0x1,0x1,0x1,0x1,
			0x1,0x1,0x1,0x1,0x1,0x1,
			0x0,0x0,0x0,0x0,0x0,0x0,
			0x0,0x0,0x0,0x0,0x0,0x0,
			0x1,0x1,0x1,0x1,0x1,0x2,
			
			0x0,0x0,0x1,0x0,0x0,0x0,
			0x0,0x0,0x1,0x0,0x1,0x0,
			0x1,0x1,0x1,0x0,0x0,0x0,
			0x0,0x0,0x0,0x0,0x0,0x0,
			0x0,0x0,0x0,0x0,0x0,0x0,
			0x0,0x0,0x0,0x0,0x0,0x0
			
	};
	
	Byte[] level3 = { 
			//1er ÃƒÆ’Ã‚Â©tage
			0x3,0x1,0x1,0x1,0x1,0x1,
			0x1,0x1,0x1,0x1,0x1,0x1,
			0x1,0x1,0x1,0x1,0x1,0x1,
			0x1,0x1,0x1,0x1,0x1,0x1,
			0x1,0x1,0x1,0x1,0x1,0x1,
			0x1,0x1,0x1,0x1,0x1,0x2,
			//2ÃƒÆ’Ã‚Â©me ÃƒÆ’Ã‚Â©tage
			0x1,0x1,0x1,0x1,0x1,0x0,
			0x1,0x1,0x1,0x1,0x1,0x0,
			0x1,0x1,0x1,0x1,0x1,0x0,
			0x1,0x1,0x1,0x1,0x1,0x0,
			0x1,0x1,0x1,0x1,0x1,0x0,
			0x0,0x0,0x0,0x0,0x0,0x0,
			//etc
			0x1,0x1,0x1,0x1,0x0,0x0,
			0x1,0x1,0x1,0x1,0x0,0x0,
			0x1,0x1,0x1,0x1,0x0,0x0,
			0x1,0x1,0x1,0x1,0x0,0x0,
			0x0,0x0,0x0,0x0,0x0,0x0,
			0x0,0x0,0x0,0x0,0x0,0x0,
			
			0x1,0x1,0x1,0x0,0x0,0x0,
			0x1,0x1,0x1,0x0,0x0,0x0,
			0x1,0x1,0x1,0x0,0x0,0x0,
			0x0,0x0,0x0,0x0,0x0,0x0,
			0x0,0x0,0x0,0x0,0x0,0x0,
			0x0,0x0,0x0,0x0,0x0,0x0,
	
			0x1,0x1,0x0,0x0,0x0,0x0,
			0x1,0x1,0x0,0x0,0x0,0x0,
			0x0,0x0,0x0,0x0,0x0,0x0,
			0x0,0x0,0x0,0x0,0x0,0x0,
			0x0,0x0,0x0,0x0,0x0,0x0,
			0x0,0x0,0x0,0x0,0x0,0x0,
			
			0x3,0x0,0x0,0x0,0x0,0x0,
			0x0,0x0,0x0,0x0,0x0,0x0,
			0x0,0x0,0x0,0x0,0x0,0x0,
			0x0,0x0,0x0,0x0,0x0,0x0,
			0x0,0x0,0x0,0x0,0x0,0x0,
			0x0,0x0,0x0,0x0,0x0,0x0,
			
			0x0,0x0,0x0,0x0,0x0,0x0,
			0x0,0x0,0x0,0x0,0x0,0x0,
			0x0,0x0,0x0,0x0,0x0,0x0,
			0x0,0x0,0x0,0x0,0x0,0x0,
			0x0,0x0,0x0,0x0,0x0,0x0,
			0x0,0x0,0x0,0x0,0x0,0x0
	};

	
	Byte[] level4 = { 
			
			0x3,0x1,0x1,0x1,0x1,0x1,
			0x1,0x1,0x1,0x1,0x1,0x1,
			0x1,0x1,0x1,0x1,0x1,0x1,
			0x1,0x1,0x1,0x1,0x1,0x1,
			0x1,0x1,0x1,0x1,0x1,0x1,
			0x1,0x1,0x1,0x1,0x1,0x2,
			
			0x0,0x0,0x0,0x0,0x0,0x0,
			0x0,0x0,0x1,0x0,0x1,0x0,
			0x0,0x0,0x1,0x0,0x1,0x0,
			0x0,0x0,0x0,0x0,0x0,0x0,
			0x0,0x0,0x0,0x0,0x1,0x0,
			0x0,0x0,0x0,0x0,0x0,0x0
			
	};
	
	
	// Il y a 2 étages pour l'éventuel ajout d'un étage
	Byte[] level5 = { 
			
			0x3,0x1,0x1,0x1,0x1,0x1,
			0x0,0x0,0x0,0x0,0x0,0x1,
			0x1,0x1,0x1,0x1,0x1,0x1,
			0x1,0x0,0x0,0x0,0x0,0x0,
			0x1,0x0,0x1,0x1,0x1,0x1,
			0x1,0x1,0x1,0x0,0x0,0x2,	
			
			0x0,0x0,0x0,0x0,0x0,0x0,
			0x0,0x0,0x0,0x0,0x0,0x0,
			0x0,0x0,0x0,0x0,0x0,0x0,
			0x0,0x0,0x0,0x0,0x0,0x0,
			0x0,0x0,0x0,0x0,0x0,0x0,
			0x0,0x0,0x0,0x0,0x0,0x0
			
	};
	

	byte[] dimensions = {
			0x6,0x6,0x1
	};

	boolean solvable;
	Byte difficulty;
	Level(){
		
	}
	
	public int getX(int niv){
		switch (niv){
		case 1:
			return 6;
		case 2:
			return 6;
		case 3:
			return 6;
		case 4 :
			return 6;
		case 5 : 
			return 6;
		default : 
			return 6;
		}
	}
	
	public int getY(int niv){
		switch (niv){
		case 1:
			return 6;
		case 2:
			return 6;
		case 3:
			return 6;
		case 4 :
			return 6;
		case 5 : 
			return 6;
		default : 
			return 6;
		}
	}

	public int getZ(int niv){
		switch (niv){
		case 1:
			return 3;
		case 2:
			return 2;
		case 3:
			return 7;
		case 4 :
			return 2;
		case 5 : 
			return 2;
		default : 
			return 1;
		}
	}
	
	
	// Fonction qui retourne le "byte" correspondant au bloc voulu
		public Byte niveau(int niv,int numbloc){
			switch (niv){
			case 1:
				return level1[numbloc];
			case 2:
				return level2[numbloc];
			case 3 :
				return level3[numbloc];
			case 4 :
				return level4[numbloc];
			case 5 :
				return level5[numbloc];
			default :
				return level1[numbloc];
			}
		}
	
	// Fonction qui retourne si oui ou non la case est une case d'arrivÃƒÂ©e (de sortie)	
		public boolean arrivee(int niv, int numbloc){
			switch (niv){
			case 1:
				if (numbloc == 35) 
					return true;
				else
					return false;
			case 2:
				if (numbloc == 35) 
					return true;
				else
					return false;
			case 3:
				if (numbloc == 35) 
					return true;
				else
					return false;
			case 4:
				if (numbloc == 35) 
					return true;
				else
					return false;
			case 5:
				if (numbloc == 35) 
					return true;
				else
					return false;
			default: 
					return false;
			}
		}



		void writelvl(String path) throws FileNotFoundException, IOException {
			FileOutputStream fos = new FileOutputStream(path);
			fos.write(level1);
//			fos.write(dimensions);
			fos.flush();
			fos.close();
		}
		//readlvl("level"+numero)
		void readlvl(String path) throws IOException {
			FileInputStream fis = new FileInputStream(path);
			fis.read(level1);
//			fis.read(dimensions);
			fis.close();
			
		}
		
}
